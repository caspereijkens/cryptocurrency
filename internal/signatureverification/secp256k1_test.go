package signatureverification

import (
	"fmt"
	"math/big"
	"testing"
)

func TestNewS256FieldElement(t *testing.T) {
	// Test with a valid value
	validValue := big.NewInt(12345) // example value within range
	element, err := NewS256FieldElement(validValue)
	if err != nil {
		t.Errorf("NewS256FieldElement failed with valid input: %s", err)
	}
	if element == nil {
		t.Error("NewS256FieldElement returned nil for valid input")
	}

	// Test with an invalid value (greater than the prime)
	invalidValue := new(big.Int).Add(S256Prime, big.NewInt(1)) // value just above the prime
	_, err = NewS256FieldElement(invalidValue)
	if err == nil {
		t.Error("NewS256FieldElement should fail with invalid input but didn't")
	}
}

func TestS256FieldElementString(t *testing.T) {
	// Test case with a known value
	testValue := big.NewInt(12345)                    // example value
	expectedString := fmt.Sprintf("%064x", testValue) // expected hex string

	element, err := NewS256FieldElement(testValue)
	if err != nil {
		t.Fatalf("Failed to create S256FieldElement: %s", err)
	}

	resultString := element.String()
	if resultString != expectedString {
		t.Errorf("String() = %s; want %s", resultString, expectedString)
	}
}

func TestNewS256Point(t *testing.T) {
	// Example valid values for x and y that satisfy the curve equation
	// You should replace these with values that are valid for your curve
	xHex := "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
	yHex := "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"

	x, _ := new(big.Int).SetString(xHex, 0)
	y, _ := new(big.Int).SetString(yHex, 0)

	validX, _ := NewS256FieldElement(x)
	validY, _ := NewS256FieldElement(y)

	point, err := NewS256Point(validX, validY)
	if err != nil {
		t.Errorf("NewS256Point failed with valid inputs: %s", err)
	}
	if point == nil {
		t.Error("NewS256Point returned nil for valid inputs")
	}

	// Example invalid values for x and y
	// You should replace these with values that are invalid for your curve
	invalidX, _ := NewS256FieldElement(big.NewInt(0))
	invalidY, _ := NewS256FieldElement(big.NewInt(0))

	_, err = NewS256Point(invalidX, invalidY)
	if err == nil {
		t.Error("NewS256Point should fail with invalid inputs but didn't")
	}
}

func TestS256PointScalarMultiplication(t *testing.T) {
	// Example valid point on the curve
	// Replace these with valid x and y values for your curve

	// Example valid coefficient
	coefficient := big.NewInt(2) // example coefficient

	// Perform scalar multiplication
	resultPoint, err := G.ScalarMultiplication(coefficient)
	if err != nil {
		t.Errorf("ScalarMultiplication failed with valid inputs: %s", err)
	}
	if resultPoint == nil {
		t.Error("ScalarMultiplication returned nil for valid inputs")
	}

	// Check the result against an expected point if you have one

	// Test with coefficient larger than N
	largeCoefficient := new(big.Int).Add(N, big.NewInt(315))
	resultPoint0, _ := G.ScalarMultiplication(largeCoefficient)
	resultPoint1, _ := G.ScalarMultiplication(big.NewInt(315))
	if !resultPoint0.Point.Equal(&resultPoint1.Point) {
		t.Error("The group generated by G is not behaving like a group")
	}
}
