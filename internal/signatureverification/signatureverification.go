package signatureverification

import (
	"fmt"
	"math/big"

	"github.com/caspereijkens/cryptocurrency/internal/ellipticcurve"
	"github.com/caspereijkens/cryptocurrency/internal/finitefield"
)

var (
	S256Prime = getS256Prime()

	A, _ = NewS256FieldElement(big.NewInt(0))
	B, _ = NewS256FieldElement(big.NewInt(7))
	N    = getS256Order()
	G    = getS256Generator()
)

type Signature struct {
	R *big.Int
	S *big.Int
}

func NewSignature(r, s *big.Int) *Signature {
	return &Signature{R: new(big.Int).Set(r), S: new(big.Int).Set(s)}
}

// S256FieldElement represents a field element with a fixed prime for secp256k1.
type S256FieldElement struct {
	finitefield.FieldElement
}

func getS256Prime() *big.Int {
	two := big.NewInt(2)
	p := new(big.Int)

	// Calculate 2^256
	twoToThe256 := new(big.Int).Exp(two, big.NewInt(256), nil)

	// Calculate 2^32
	twoToThe32 := new(big.Int).Exp(two, big.NewInt(32), nil)

	// Subtract 2^32 and 977 from 2^256
	p.Sub(twoToThe256, twoToThe32)
	p.Sub(p, big.NewInt(977))
	return p
}

// NewS256FieldElement creates a new Secp256k1FieldElement with the fixed prime.
func NewS256FieldElement(value *big.Int) (*S256FieldElement, error) {
	f, err := finitefield.NewFieldElement(value, S256Prime)
	if err != nil {
		return nil, err
	}
	return &S256FieldElement{*f}, nil
}

// String returns the string representation of a field element.
func (a *S256FieldElement) String() string {
	return fmt.Sprintf("%064x", a.Value)
}

type S256Point struct {
	ellipticcurve.Point
}

func getS256Order() *big.Int {
	// Since the generator Point is known, the group that it generates and so its order are also known.
	// This is the hex value of this order.
	orderHex := "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"

	// Set the big int to your large number
	order, _ := new(big.Int).SetString(orderHex, 0)

	return order

}

func NewS256Point(x, y *S256FieldElement) (*S256Point, error) {
	p, err := ellipticcurve.NewPoint(&x.FieldElement, &y.FieldElement, &A.FieldElement, &B.FieldElement)
	if err != nil {
		return nil, err
	}
	return &S256Point{*p}, nil
}

func (p256 *S256Point) ScalarMultiplication(coefficient *big.Int) (*S256Point, error) {
	// We mod by N because that is the order of the Group generated by this specific point.
	// In other words, every n times we cycle back to the identiy.
	p, err := p256.Point.ScalarMultiplication(new(big.Int).Mod(coefficient, N))
	if err != nil {
		return nil, err
	}
	return &S256Point{*p}, nil
}

func (sig *Signature) String() string {
	return fmt.Sprintf("Signature(%x,%x)", sig.R, sig.S)
}

func (p256 *S256Point) Verify(z *big.Int, sig *Signature) bool {
	// Calculate s_inv (modular inverse of s)
	sInv := new(big.Int).ModInverse(sig.S, N)
	if sInv == nil {
		return false
	}

	// Calculate u and v
	u := new(big.Int).Mod(new(big.Int).Mul(z, sInv), N)
	v := new(big.Int).Mod(new(big.Int).Mul(sig.R, sInv), N)

	// Calculate u*G and v*P
	uG, err := G.ScalarMultiplication(u)
	if err != nil {
		return false
	}
	vPoint, err := p256.ScalarMultiplication(v)
	if err != nil {
		return false
	}

	// Add the two points
	sumPoint, err := uG.Add(&vPoint.Point)
	if err != nil {
		return false
	}

	// Check if the x-coordinate of the result matches r
	if sumPoint.X.Value.Cmp(sig.R) != 0 {
		return false
	}

	return true
}

func getS256Generator() *S256Point {
	// https://crypto.stackexchange.com/questions/60420/what-does-the-special-form-of-the-base-point-of-secp256k1-allow
	xHex := "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
	yHex := "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"

	x, _ := new(big.Int).SetString(xHex, 0)
	y, _ := new(big.Int).SetString(yHex, 0)

	xF, _ := NewS256FieldElement(x)
	yF, _ := NewS256FieldElement(y)

	generator, _ := NewS256Point(xF, yF)
	return generator
}
